% Content:
%
% Cyrillic startup definitions:
%  load components absent in Computer Modern parameters files
%  redefined font_setup
% Advanced cmbase's definitions
%  macros for cyr letter's drawing
%  macro for accent cyrbreve - cyrillic breve
% Exbase's special routines for accenting
%  (borrowed part from exbase)
% Macros for processing chars twice
%  (borrowed part from exbase)
% Accents which created with beginchar_twice routine
%  (borrowed from exaccess)
%


let lhchar=\; % `|lhchar|' should precede each character

   def cyrchar_twice(suffix $)(expr w_sharp,h_sharp,d_sharp) =
       iff known CYR_.$: beginchar_twice(CYR_.$,w_sharp,h_sharp,d_sharp);
   enddef;

%
% load components absent in parameter files
%

   if monospace: % borrowed from ectt
      basedef                     ( 8,      9,   10,   12);
      gendef[1/36pt#](acc_height#)(60,   67.5,   75,   90);
      gendef[1/36pt#](dot_height#)(60,   67.5,   75,   90);
   else: % borrowed from ecrm
      basedef                     (   5,    6,    7,  8,    9, 10,   12, 17.28);
      gendef[1/36pt#](acc_height#)(42.5,   49, 55.5, 62, 68.5, 75,   90, 127.5);
      gendef[1/36pt#](dot_height#)(  42, 46.6, 51.2, 56, 60.4, 66, 77.2,   100);
   fi

sbeak#     := (if serifs: max(beak#,3/4desc_depth#) else: desc_depth# fi) /1.2;
cap_sbeak# :=  if serifs: max(beak#,3/4desc_depth#) else: desc_depth# fi;

%
% add absent exbase parameters in cmbase's font_setup
% original font_setup macro redefined to ADD necessary settings in it's context
%
let font_setup_ = font_setup;

def font_setup =
    font_setup_;
    define_whole_blacker_pixels(acc_height);
    define_pixels(cap_sbeak,sbeak);
    pickup pencircle scaled min(hair,vair);
    extra_rule.nib:=savepen;
enddef;

%
% booleans for lowercase/uppercase identifying
%
boolean cyrcaph, cyrcaph.cyrcaph;
cyrcaph          = false;
cyrcaph.cyrcaph  = true;

%
% advanced cmbase's definitions: macros for cyr letter's drawing
%   set_bar_axis, bar_stroke
%   cyr_serif, l_serif, r_serif
%   cyrbulb
%   cbreve

% sets for bar axis in lowercase letters
%
vardef set_bar_axis =
    pickup tiny.nib; y1.bh:=vround(.55x_height-.6[thin_join,vair]/2);
    y2.bh:=y1.bh+.6[thin_join,vair]; y0.bh:=.5[y2.bh,y1.bh];
enddef;

vardef bar_stroke(expr left_jut,right_jut) = % |x$r| and |x$$r| (only) are known
    if left_jut>right_jut: errmessage ("change `bar' points"); fi
    fix_virgin z;
    set_bar_axis;
    if serifs: pickup crisp.nib; else: pickup fine.nib; fi
    if (y2.bh-y1.bh)>(currentbreadth+eps):
       pos[ii](.6[thin_join,vair],90); pos[jj](.6[thin_join,vair],90);
       lft x[ii]r=left_jut; rt x[jj]r=right_jut;
       top y[ii]r=top y[jj]r=y2.bh;
       filldraw stroke z[ii]e--z[jj]e; % bar
    else:
       y[ii]l=y[jj]l=y1.bh; y[ii]r=y[jj]r=y2.bh;
       x[ii]l=x[ii]r=left_jut; x[jj]l=x[jj]r=right_jut;
       fill z[jj]l{right}...{left}z[jj]r--z[ii]r{left}...{right}z[ii]l--cycle; % bar
    fi
    penlabels([ii],[jj]);
enddef;

%
% Cyrillic descender serif
%
vardef cyr_serif(suffix $,$$,@)  % serif at |z$| for stroke from |z$$|
                (expr darkness,beak_darkness,jut,beak_jut) =
    if serifs:
          pickup crisp.nib;
    else:
          pickup pencircle scaled (3/5[fine,crisp]+eps);
    fi
    numeric bracket_height,light_stem; pair downward;
    bracket_height=bracket;
    light_stem=hround (max(tiny.breadth,fudged.hair if hefty:-4stem_corr fi));
    % for cyr_serif always |y$|<|y$$|
    if (y$>y$$): errmessage ("`cyr_serif' placed only on the bottom"); fi
    downward=z$-z$$;
    y@0=min(y$+bracket_height,y$$)+eps;
    top y@1-slab-eps=bot y@4+eps=tiny.bot y$;
    if y@1>y@0: y@0:=y@1+eps; fi
    bot y@2=bot y@3=vround(-d);
    y@5=y@1; y@6=y@0;
    z@5=whatever[z$,z$$]; z@6=whatever[z$,z$$];
    if jut<0:
       z@0+penoffset downward of currentpen =
           z$l+penoffset downward of pen_[tiny.nib]+whatever*downward;
       lft x@1=hround (tiny.lft x$l+jut)-eps;
       if x@6<x@0+eps: x@6:=x@0+eps; fi
       lft x@2=rt x@3-light_stem-eps=hround (lft x@1+beak_jut)-eps;
       x@4=x$+.5(fudged.stem-3stem_corr-tiny)+eps;
    else:
       z@0-penoffset downward of currentpen =
           z$r-penoffset downward of pen_[tiny.nib]-whatever*downward;
       rt x@1=hround (tiny.rt x$r+jut)+eps;
       if x@6>x@0-eps: x@6:=x@0-eps; fi
       rt x@2=lft x@3+light_stem+eps=hround (rt x@1+beak_jut)+eps;
       x@4=x$-.5(fudged.stem-3stem_corr-tiny)-eps;
    fi
    pair corner,beak_corner;
    ypart corner=y@1; corner=z@0+whatever*downward;
    ypart beak_corner=y@4; beak_corner=z@3+whatever*(z@1-z@2);
    if jut<0:
       filldraw z@0{z$-z$$}
           ...(darkness+eps)[corner,.5[z@1,z@0]]{z@1-z@0}
           ...{jut,0}z@1--z@2--z@3{z@1-z@2}
           ...(beak_darkness+eps)[beak_corner,.5[z@3,z@4]]
           ...{-jut,0}z@4--(x@4,y@1)--z@5--z@6--cycle; % descender
    else:
       filldraw z@6--z@5--(x@4,y@1)--z@4{jut,0}
           ...(beak_darkness+eps)[beak_corner,.5[z@3,z@4]]
           ...{z@2-z@1}z@3--z@2--z@1{-jut,0}
           ...(darkness+eps)[corner,.5[z@1,z@0]]{z@0-z@1}
           ...{z$$-z$}z@0--cycle; % descender
    fi
    labels (@0,@1,@2,@3,@4,@5,@6);
enddef;

%
% roman descenders
%
def r_serif(suffix $,$$,@)  % descender at |z$| for stroke from |z$$|
           (expr left_darkness,left_jut)
           (suffix @@)
           (expr right_darkness,beak_darkness,right_jut,beak_jut) =
    serif($,$$,@,left_darkness,-left_jut);
    cyr_serif($,$$,@@,right_darkness,beak_darkness,right_jut,beak_jut);
enddef;

%
% italic descender
%
def i_serif(suffix $,@) =   % vawed italic descender
    y@1=.5[y$,y@2r]; x@1r=x$r;
    numeric theta,slope;
    theta=angle(-max(3u,u+2curve),d);
    slope=-angle(-max(2u,u+curve),d);
    pos@1(.5[vair,hair],180);
    pos@2(7/8[hair,curve],theta);
    pos@3(vair,theta);
    lft x@2r=lft x@1r+max(.5hair,1)+eps;
    y@2r=-.35d;
    bot y@3l=-d-oo;
    z@3l=z@2l+hair*dir (if monospace: .5 fi theta)+whatever*dir slope;
    filldraw stroke z$e{down}...z@1e...z@2e{down}....{dir (slope)}z@3e;
    penlabels (@1,@2,@3);
enddef;

%
% redefined bulb: ... with directions instead of --
%
def cyrbulb(suffix $,$$,$$$) =
    z$$$r=z$$r;
    path_.l:=z$l{x$$r-x$r,0}...{0,y$$r-y$r}z$$l;
    path p_; p_:=z$r{x$$r-x$r,0}...{0,y$$r-y$r}z$$r;
    filldraw path_.l--reverse p_--cycle; % link
    path_.r:=z$$$l{0,y$r-y$$r}..z$$$r{0,y$$r-y$r}; % near-circle
    y_:=xpart(path_.r intersectiontimes p_);
    if y_<0: y_:=1; fi
    filldraw subpath(0,y_) of path_.r
       {dir (angle direction y_ of p_)}...%--
       z$$r{0,y$$r-y$r}..cycle; % bulb
enddef;

%
% cbreve accent for Cyrillic letters
%
boolean altaccent; altaccent=false;

vardef cbreve(expr x_center,y_move,
             _one,_two,_three,_four,_five,_six,_seven) suffix modifier =
    numeric mid_thickness,bulb_diam;
    mid_thickness=max(crisp.breadth,vround if serifs: 1/5 else: 1/3 fi[vair,stem]);
    bulb_diam=max(crisp.breadth,hround(max(dot_size,cap_curve)-2stem_corr));
    pickup crisp.nib;
    pos[_one](bulb_diam,0); pos[_two](bulb_diam,90);
    x[_one]=x[_two]=x_center-1.75u if monospace: /expansion_factor fi;
    if cyrcaph.modifier:
        bot y[_six]r=vround (y_move+max(
               min(cap_height+o+max(tiny,0.5mid_thickness),
                   cap_height+0.3acc_height),
               1/3[cap_height,min(asc_height,2x_height)]+o-.5mid_thickness
            ));
        top y[_two]r=vround (y_move+max(
               (cap_height+dot_height#*hppp),
               bot y[_six]r+mid_thickness+bulb_diam+eps
            ));
    else:
        bot y[_six]r=vround (y_move+max(
                min(x_height+o+max(tiny,0.5mid_thickness),
                    x_height+0.3acc_height),
                if serifs:
                    1/3[x_height, min(asc_height,2x_height)
                                  -cap_height+x_height]
                else:
                    1/3[x_height,h]
                fi + o - 0.5mid_thickness
            ));
        top y[_two]r=vround (y_move+max(
                (x_height+dot_height#*hppp),
                bot y[_six]r+mid_thickness+bulb_diam+eps
            ));
    fi
    y[_one]=y_move+.5[y[_two]l,y[_two]r];
    pos[_three](bulb_diam,0);
    penpos[_four](y[_two]r-y[_two]l,90);
    y[_three]=y[_four]=y[_one];
    x[_three]=x[_four]=x[_one]+3.5u if monospace: /expansion_factor fi;
    if square_dots: % no dots in sans serif cyrbreve
        x[_six]=hround x_center;
        lft x[_five]r=hround(x[_six]-2.5u
                  if monospace: /expansion_factor fi-.5vair);
        rt x[_seven]r=hround(x[_six]+2.5u
                  if monospace: /expansion_factor fi+.5vair);
        top y[_five]=top y[_seven]=h+y_move; % common for both upper and lower
        if y[_six]r>(bot y[_seven]-eps):
              y[_six]r:=bot y[_seven]-eps;
        fi
    else:
        dot([_one],[_two]); % left dot
        if not altaccent:
           dot([_three],[_four]); % right dot
        fi
        x[_six]=.5[x[_one]l,x[_three]r];
        lft x[_five]r=lft x[_one]l;
        rt x[_seven]r=rt x[_three]r;
        top y[_five]=top y[_seven]=y[_two]; % common for both upper and lower
    fi
    pos[_five](vair,-180);
    pos[_seven](vair,0);
    pos[_six](mid_thickness,-90);
    filldraw stroke z[_five]e{down}
          ...z[_six]e{right}
          ...{up}z[_seven]e;  % stroke
    penlabels ([_five],[_six],[_seven]);
enddef;

%%% fine hi higher
% |higher| is a counterpart to |lower| (see the file excsc.mf),
% |hi| facilitates using higher values (which are reference points in
% the floating world of CM fonts)
def hi = if is_small_cap: higher fi\\ enddef;

%
%  special routines for accenting bowwowed from ecfonts but rearranged
%
%!!!lhfonts: first goes umlaut for yo
vardef lowercase_umlaut(expr x_move,y_move,umlaut_one,umlaut_two,
   umlaut_three,umlaut_four) =
numeric dot_dist; dot_dist:=round(3.5u); % (CMBRIGHT)
pickup tiny.nib;
pos[umlaut_one](udot_diam,0);
pos[umlaut_two](udot_diam,90);
%x[umlaut_one]=x[umlaut_two]=x_move+.5w-1.75u if monospace:/expansion_factor fi ;
x[umlaut_one]=x[umlaut_two]=x_move+.5w-0.5dot_dist %(CMBRIGHT)
 if monospace:/expansion_factor fi ;               %(CMBRIGHT)
top y[umlaut_two]r=lc_trema_height;
y[umlaut_one]=y_move+.5[y[umlaut_two]l,y[umlaut_two]r];
dot([umlaut_one],[umlaut_two]);  % left dot
pos[umlaut_three](udot_diam,0);
penpos[umlaut_four](y[umlaut_two]r-y[umlaut_two]l,90);
y[umlaut_three]=y[umlaut_four]=y[umlaut_one];
x[umlaut_three]=x[umlaut_four]=x[umlaut_one]
%     +3.5u if monospace: /expansion_factor fi ;
     +dot_dist if monospace: /expansion_factor fi ; % (CMBRIGHT)
dot([umlaut_three],[umlaut_four]);  % right dot
enddef;
%
vardef uppercase_umlaut(expr x_move,y_move,umlaut_one,umlaut_two,
   umlaut_three,umlaut_four) =
numeric dot_dist; dot_dist:=round(3.5u); % (CMBRIGHT)
pickup tiny.nib;
pos[umlaut_one](udot_diam,0);
pos[umlaut_two](udot_diam,90);
%x[umlaut_one]=x[umlaut_two]=x_move+.5w-1.75u if monospace:/expansion_factor fi ;
x[umlaut_one]=x[umlaut_two]=x_move+.5w-0.5dot_dist %(CMBRIGHT)
 if monospace:/expansion_factor fi ;               %(CMBRIGHT)
top y[umlaut_two]r=vround(cap_height+dot_height#*hppp);
y[umlaut_one]=y_move+.5[y[umlaut_two]l,y[umlaut_two]r];
dot([umlaut_one],[umlaut_two]);  % left dot
pos[umlaut_three](udot_diam,0);
penpos[umlaut_four](y[umlaut_two]r-y[umlaut_two]l,90);
y[umlaut_three]=y[umlaut_four]=y[umlaut_one];
x[umlaut_three]=x[umlaut_four]=x[umlaut_one]
%     +3.5u if monospace: /expansion_factor fi ;
     +dot_dist if monospace: /expansion_factor fi ; % (CMBRIGHT)
dot([umlaut_three],[umlaut_four]);  % right dot
enddef;

%
%                   MACROS FOR PROCESSING CHARS TWICE:
%             PASS 1: COLLECTING TFM (SHARP) INFORMATION
%             PASS 2: CREATING THE GLYPH
%
%%% define_pixels prepare_pen
%%% beginchar beginchar_twice
%%% endfor repeat_once

def clear_mode_guards =
  forsuffixes $=proofing,fontmaking,tracingtitles,pixels_per_inch,
    blacker,fillin,o_correction,blacker_min,aspect_ratio:
      numeric mode_guard_$;
  endfor
enddef;

let ori_draw:=draw;
let ori_fill:=fill;
let ori_filldraw:=filldraw;
let ori_erase:=erase;
let ori_penstroke:=penstroke;
let ori_special:=special;
let ori_numspecial:=numspecial;

mode_def canonical_sharp_mode = % nearly |proof| mode
 proofing:=0;                   % no, we aren't making full proofs
 fontmaking:=0;                 % yes, we are making a font
 tracingtitles:=0;              % don't show titles online
 pixels_per_inch:=2601.72;      % that's 36 pixels per pt
 blacker:=0;                    % no additional blackness
 blacker_min:=0;                % no write_white provision
 fillin:=0;                     % no compensation for fillin
 o_correction:=1;               % no reduction in overshoot
enddef;

def beginchar_twice(expr c,w_sharp,h_sharp,d_sharp) =
 begingroup
  if string mode: string prev_mode; prev_mode:=mode;
  else: numeric prev_mode; prev_mode:=mode;
  fi
  for sharp_calc_:=1,whatever:
%  |sharp_calc| is checked in |corrital|, |mark_height|, and |put_accent|
   sharp_calc:=sharp_calc_;
   if known sharp_calc: % carry out ``sharp'' calculations
    begingroup save mode,mag; mode:=canonical_sharp_mode;
    clear_mode_guards; mode_setup; font_setup; pseudo_setup;
    if is_small_cap: % excerpt from |font_setup|
      define_pixels(higher.u,higher.bar_height);
      define_corrected_pixels(higher.o);
      define_whole_pixels(higher.letter_fit);
      define_whole_vertical_pixels(higher.x_height,higher.body_height);
      define_whole_blacker_pixels(higher.stem);
    fi
    endgroup;
    def draw expr e=enddef;
    let fill:=draw;
    let filldraw:=draw;
    let erase:=killtext; % |killtext| was absent from earlier versions of plain
    let penstroke:=killtext;
    def special primary t = enddef;
    def numspecial primary t = enddef;
    charwd:=w_sharp; charht:=h_sharp; chardp:=d_sharp; charic:=0;
   else: % carry out ``discrete'' calculations
    mode:=prev_mode;
    clear_mode_guards; mode_setup; font_setup; pseudo_setup;
    if is_small_cap: % excerpt from |font_setup|
      define_pixels(higher.u,higher.bar_height);
      define_corrected_pixels(higher.o);
      define_whole_pixels(higher.letter_fit);
      define_whole_vertical_pixels(higher.x_height,higher.body_height);
      define_whole_blacker_pixels(higher.stem);
    fi
    let draw:=ori_draw;
    let fill:=ori_fill;
    let filldraw:=ori_filldraw;
    let erase:=ori_erase;
    let penstroke:=ori_penstroke;
    let special:=ori_special;
    let numspecial:=ori_numspecial;
    charwd:=w_sharp;
   fi
   charcode:=if known c: byte c else: 0 fi;
   w:=hround(w_sharp*hppp); h:=vround(h_sharp*hppp); d:=vround(d_sharp*hppp);
   clearxy; clearit; clearpen; scantokens extra_beginchar;
enddef;

let repeat_once = endfor;

%
%                         GENERAL PURPOSE ACCESSORIES
%

%%% top is_known
%%% top fix_virgin
vardef is_known z suffix $ =
% an auxiliary macro for |fix_virgin z|, used also while constructing ogoneks
 (known x$) or (known x$l) or (known x$r)\\ or
 (known y$) or (known y$l) or (known y$r)
enddef;

vardef fix_virgin z = % find a pair of virgin pairs
 numeric ii,jj; jj:=1;
 forever:
  if is_known z[jj] or is_known z[jj+1]: % unknown gaps may occur
  jj:=incr jj else: jj=ii fi; exitif known ii;
 endfor;
 jj:=ii+1;
% now |ii| and |jj| are such that |z[ii]| and |z[jj]| are ``untouched''
enddef;

%%% italcorr corrital
% correction of italic correction (cf. D. E. Knuth, The \MF{}book, p. 105):
vardef corrital z suffix $ =
% |z$| is the rightmost position of a pen (in accent path)
 if known sharp_calc:
  if not monospace:
   save charic_; charic_=(rt(x$)-r)/hppp+slant*y$/vppp+.5u#;
   if charic_>charic: charic:=charic_; fi
  fi
%| else: %| |charic=mono_charic#|, do nothing
 fi
enddef;

%%% top prepare_pen
def prepare_pen suffix $ =
%%% fine $ %%%% temporary MFT convention
  if $>fudged.hair: $:=fudged.hair; fi
  $.breadth:=$;
  pickup if $=0: nullpen else: pencircle scaled $; $:=$-eps fi;
  $.nib:=savepen; breadth_[$.nib]:=$;
  forsuffixes $$=lft,rt,top,bot: shiftdef($.$$,$$ 0); endfor
%%% qq $ %%%% ordinary MFT convention
enddef;

% The proportion of |vair/stem| depends drastically on resolution;
% e.g., for 300 dpi cmbx10 |vair=1| and |stem=5|, for 746 dpi cmbx10
% (300 dpi, magstep 5) |vair=4| and |stem=12|, while, sharply speaking,
% |stem#/vair#=3.15381|; hence a new variable |xvair| has been introduced
% to be used in some crucial places instead of |vair|.
vardef xvair = stem*vair#/stem# enddef;
